{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django file form Django-file-form helps you to write forms with a pretty ajax upload. Features: You can easily add an ajax file-upload to a form. The ajax upload works the same as an html upload. This means that you don't have to change your code to support ajax upload. Supports single and multiple file upload. Supports edition of uploaded files. Supports upload directly to AWS S3 compatible storages. Supports frontend events for the addition and removal of files. Supports addition of arbitrary file meta data and related widgets. The project is hosted on github . Works with Django 4.2, 5.0 and 5.1 Also with Python 3.8 - 3.13 Older versions: Django-file-form 3.6.x supports Django 3.2 Django-file-form 3.5.x supports Django 4.1","title":"Home"},{"location":"#django-file-form","text":"Django-file-form helps you to write forms with a pretty ajax upload. Features: You can easily add an ajax file-upload to a form. The ajax upload works the same as an html upload. This means that you don't have to change your code to support ajax upload. Supports single and multiple file upload. Supports edition of uploaded files. Supports upload directly to AWS S3 compatible storages. Supports frontend events for the addition and removal of files. Supports addition of arbitrary file meta data and related widgets. The project is hosted on github . Works with Django 4.2, 5.0 and 5.1 Also with Python 3.8 - 3.13 Older versions: Django-file-form 3.6.x supports Django 3.2 Django-file-form 3.5.x supports Django 4.1","title":"Django file form"},{"location":"admin/","text":"Django admin Use FileFormAdmin instead of ModelAdmin to support django-file-form uploads. from django_file_form.model_admin import FileFormAdmin class ExampleAdmin(FileFormAdmin): pass admin.site.register(Example, ExampleAdmin) Also see the testproject in the repository. Inline forms are not supported.","title":"Admin"},{"location":"admin/#django-admin","text":"Use FileFormAdmin instead of ModelAdmin to support django-file-form uploads. from django_file_form.model_admin import FileFormAdmin class ExampleAdmin(FileFormAdmin): pass admin.site.register(Example, ExampleAdmin) Also see the testproject in the repository. Inline forms are not supported.","title":"Django admin"},{"location":"auto_initialize/","text":"Auto initialize javascript You can initialize the file form by including file_form/auto_init.js . You don't have to call initUploadFields in your own javascript. You still have to include file_form/file_form.js and you have to include it before file_form/auto_init.js .","title":"Auto initialize javascript"},{"location":"auto_initialize/#auto-initialize-javascript","text":"You can initialize the file form by including file_form/auto_init.js . You don't have to call initUploadFields in your own javascript. You still have to include file_form/file_form.js and you have to include it before file_form/auto_init.js .","title":"Auto initialize javascript"},{"location":"changelog/","text":"Changelog 3.9.0 (april 8 2025) Support Django 5.2; drop support for Django 5.0 3.8.2 (march 9 2025) Issue #1018: correctly compile javascript bundle 3.8.1 (march 8 2025) Issue #1011: handle a model form with an empty value (thanks to Darien Reese) Issue #1018: make the extension match case insensitive 3.8.0 (august 14 2024) Issue #880. Support Django 5.1 3.7.0 (june 27 2024) Issue #784: compile to es6. This reduces the size of the minified js file to 80k (from 119k) Issue #841. Drop support for Django 3.2 Issue #891: handle error with empty initial file in model form (thanks to Yanhui Xie) 3.6.0 (december 8 2023) Issue #748: support Django 5.0 3.5.4 (28 october 2023) Issue #760: support django storages 1.14 3.5.3 (3 september 2023) Issue #680: support the disabled property Issue #685: use a path for the location header to prevent mixed content issues (thanks to Walter Lorenzetti) 3.5.2 (31 may 2023) Issue #667: uploadComplete sends wrong element with multiple file forms on a page Issue #669: rename the minified version to file_form.min.js 3.5.1 (4 may 2023) Issue #638: handle modelform field without associated file (thanks to Walter Lorenzetti) 3.5.0 (4 april 2023) Isssue #614: prevent uploading multiple files for a single file upload (thanks to Krzysztof Kosiorek) Support Django 4.2 3.4.4 (30 january 2023) Issue #588: remove temporary uploaded file when deleting a submitted upload Issue #590: add the file id to the onClick handler 3.4.3 (14 january 2023) Issue #579: onClick handler (thanks to mi01) 3.4.2 (7 december 2022) Issue #531: add Finnish translations (thanks to Tuomas Vihinen) Issue #555: code scanning alert 3.4.1 (31 august 2022) Issue #523: add package lock file (thanks to Saurabh Kumar) Issue #524: add js validation for acceptable file types (thanks to Saurabh Kumar) Issue #528: fix single upload input 3.4.0 (5 august 2022) Issue #521: support Django 4.1 3.3.2 (1 june 2022) Issue #514: prevent migrations when the DEFAULT_AUTO_FIELD is set. The TemporaryUploadedFile model now uses AutoField. 3.3.1 (2 april 2022) Issue #498: added spanish translations (thanks to Juan Helios Garc\u00eda Guzm\u00e1n) Issue #504: handle multiple 'upload failed' error messages (thanks to Krzysztof Kosiorek) 3.3.0 (8 december 2021) Support Django 4.0 3.2.3 (3 october 2021) Issue #471: fix security advice: uncontrolled data used in path expression Issue #481: make cache timeout configurable (thanks to Seb Haase) 3.2.2 (17 june 2021) Issue #456: handle data parameter with the None value Issue #465: remove unused FILE_FORM_MAX_FILE_SIZE setting Issue #468: fix modelformset with S3 upload 3.2.1 (20 april 2021) Issue #445: fix ModelForm update with multiple files (thanks to Arcuri Davide) 3.2.0 (6 april 2021) Issue #443: support Django 3.2 Issue #446: add AWS_S3_REGION_NAME and AWS_S3_SIGNATURE_VERSION settings (thanks to Niklas Wahl) Issue #449: add German translations (thanks to Niklas Wahl) 3.1.5 (29 march 2021) Issue #211: auto initialize javascript Issue #339: Django admin support 3.1.4 (8 march 2021) Issue #436: allow customization of the widget (thanks to Bo Peng) Issue #439: support ModelForm 3.1.3 (19 january 2021) Issue #422: add model rename to migrations (thanks to Shrikrishna Singh) 3.1.2 (27 december 2020) Issue #418: correctly remove upload 3.1.1 (26 november 2020) Issue #388: add cross-site request forgery protection to tus uploads using the standard Django csrf token Issue #393: fix delete-unused-files command (thanks to Seb Haase) issue #401: optimization: use move instead of copy when possible 3.1.0 (15 september 2020) Issue #324: get placeholder file for UploadWidget (thanks to Shrikrishna Singh) Issue #330: allow upload directly to S3 compatible storages (thanks to Bo Peng) Issue #331: fix error in deleting files (thanks to Bo Peng) Issue #333: replace existing uploaded file with the same name (thanks to Bo Peng) Issue #341: add javascript events (experimental) Issue #346: allow definition of s3_upload_dir in form class (thanks to Bo Peng) 3.0.1 (4 september 2020) Issue #347: add chunkSize parameter to avoid request error in Django 3.0.0 (6 august 2020) Issue #320: fix UploadMultipleWidget to return correct placeholder files (thanks to Shrikrishna Singh) Issue #325: support Django 3.1 2.2.0 (22 july 2020) Issue #315: file is not removed after form error Issue #313: allow using custom storage and custom cache (thanks to Balazs Endresz) 2.1.3 (20 june 2020) Issue #304: rewrite frontend in typescript Issue #305: don't change migration when setting changes (thanks to Lionqueen94) Issue #307: add French translations; also make translations discoverable by makemessages (thanks to Simon Maillard) 2.1.2 (20 april 2020) Issue #298: directory support for drop area Issue #300: add migration so makemigrations will not create one (thanks to Lionqueen94) 2.1.1 (7 april 2020) Issue #290: add javascript callbacks (thanks to Peter Dekkers) Issue #296: fix progress bar Issue #297: add retry delays 2.1.0 (28 march 2020) Issue #266: allow relative FILE_FORM_UPLOAD_DIR setting (thanks to Bo Peng) Issue #267: add drop area (thanks to Bo Peng) Issue #275: show size of uploaded files (thanks to Bo Peng) Issue #278: allow the addition of placeholder files (thanks to Bo Peng) Issue #280: remove option FILE_FORM_FILE_STORAGE 2.0.3 (15 february 2020) Issue #237: using with form set (thanks to Juan Carlos Carvajal) Issue #259: include uncompressed js Issue #260: correctly use formset prefix (thanks to Gzuba) Issue #261: fix default for FILE_FORM_UPLOAD_DIR (thanks to Gzuba) 2.0.2 (14 january 2020) Issue #247: support form wizard (thanks to Lionqueen94) Issue #251: delete after submit 2.0.1 (6 january 2020) Issue #240: add empty dff files div (thanks to Lionqueen94) Issue #241: Csp compliance (thanks to Lionqueen94) 2.0 (30 december 2019) Use tus instead of fine uploader 1.0 (5 december 2019) Drop support for Python 2 and Django < 2 Issue #217: update fine uploader Issue #219: use Selenium for all tests Issue #222: use pathlib2 (instead of pathlib) Issue #235: support Django 3.0 0.4.2 (3 March 2019) Issue #207: support form prefixes (thanks to Iw108) Issue #201: fix multiple file upload without ajax (thanks to Lionqueen94) 0.4.1 (5 January 2019) Issue #194: correctly call is_authenticated (thanks to Dureba) 0.4.0 (3 August 2018) Support Django 2.1 and Python 3.7 Issue #173: add i18n to upload widget (thanks to Arman Roomana) 0.3.0 (6 December 2017) Support Django 2.0","title":"Changelog"},{"location":"changelog/#changelog","text":"3.9.0 (april 8 2025) Support Django 5.2; drop support for Django 5.0 3.8.2 (march 9 2025) Issue #1018: correctly compile javascript bundle 3.8.1 (march 8 2025) Issue #1011: handle a model form with an empty value (thanks to Darien Reese) Issue #1018: make the extension match case insensitive 3.8.0 (august 14 2024) Issue #880. Support Django 5.1 3.7.0 (june 27 2024) Issue #784: compile to es6. This reduces the size of the minified js file to 80k (from 119k) Issue #841. Drop support for Django 3.2 Issue #891: handle error with empty initial file in model form (thanks to Yanhui Xie) 3.6.0 (december 8 2023) Issue #748: support Django 5.0 3.5.4 (28 october 2023) Issue #760: support django storages 1.14 3.5.3 (3 september 2023) Issue #680: support the disabled property Issue #685: use a path for the location header to prevent mixed content issues (thanks to Walter Lorenzetti) 3.5.2 (31 may 2023) Issue #667: uploadComplete sends wrong element with multiple file forms on a page Issue #669: rename the minified version to file_form.min.js 3.5.1 (4 may 2023) Issue #638: handle modelform field without associated file (thanks to Walter Lorenzetti) 3.5.0 (4 april 2023) Isssue #614: prevent uploading multiple files for a single file upload (thanks to Krzysztof Kosiorek) Support Django 4.2 3.4.4 (30 january 2023) Issue #588: remove temporary uploaded file when deleting a submitted upload Issue #590: add the file id to the onClick handler 3.4.3 (14 january 2023) Issue #579: onClick handler (thanks to mi01) 3.4.2 (7 december 2022) Issue #531: add Finnish translations (thanks to Tuomas Vihinen) Issue #555: code scanning alert 3.4.1 (31 august 2022) Issue #523: add package lock file (thanks to Saurabh Kumar) Issue #524: add js validation for acceptable file types (thanks to Saurabh Kumar) Issue #528: fix single upload input 3.4.0 (5 august 2022) Issue #521: support Django 4.1 3.3.2 (1 june 2022) Issue #514: prevent migrations when the DEFAULT_AUTO_FIELD is set. The TemporaryUploadedFile model now uses AutoField. 3.3.1 (2 april 2022) Issue #498: added spanish translations (thanks to Juan Helios Garc\u00eda Guzm\u00e1n) Issue #504: handle multiple 'upload failed' error messages (thanks to Krzysztof Kosiorek) 3.3.0 (8 december 2021) Support Django 4.0 3.2.3 (3 october 2021) Issue #471: fix security advice: uncontrolled data used in path expression Issue #481: make cache timeout configurable (thanks to Seb Haase) 3.2.2 (17 june 2021) Issue #456: handle data parameter with the None value Issue #465: remove unused FILE_FORM_MAX_FILE_SIZE setting Issue #468: fix modelformset with S3 upload 3.2.1 (20 april 2021) Issue #445: fix ModelForm update with multiple files (thanks to Arcuri Davide) 3.2.0 (6 april 2021) Issue #443: support Django 3.2 Issue #446: add AWS_S3_REGION_NAME and AWS_S3_SIGNATURE_VERSION settings (thanks to Niklas Wahl) Issue #449: add German translations (thanks to Niklas Wahl) 3.1.5 (29 march 2021) Issue #211: auto initialize javascript Issue #339: Django admin support 3.1.4 (8 march 2021) Issue #436: allow customization of the widget (thanks to Bo Peng) Issue #439: support ModelForm 3.1.3 (19 january 2021) Issue #422: add model rename to migrations (thanks to Shrikrishna Singh) 3.1.2 (27 december 2020) Issue #418: correctly remove upload 3.1.1 (26 november 2020) Issue #388: add cross-site request forgery protection to tus uploads using the standard Django csrf token Issue #393: fix delete-unused-files command (thanks to Seb Haase) issue #401: optimization: use move instead of copy when possible 3.1.0 (15 september 2020) Issue #324: get placeholder file for UploadWidget (thanks to Shrikrishna Singh) Issue #330: allow upload directly to S3 compatible storages (thanks to Bo Peng) Issue #331: fix error in deleting files (thanks to Bo Peng) Issue #333: replace existing uploaded file with the same name (thanks to Bo Peng) Issue #341: add javascript events (experimental) Issue #346: allow definition of s3_upload_dir in form class (thanks to Bo Peng) 3.0.1 (4 september 2020) Issue #347: add chunkSize parameter to avoid request error in Django 3.0.0 (6 august 2020) Issue #320: fix UploadMultipleWidget to return correct placeholder files (thanks to Shrikrishna Singh) Issue #325: support Django 3.1 2.2.0 (22 july 2020) Issue #315: file is not removed after form error Issue #313: allow using custom storage and custom cache (thanks to Balazs Endresz) 2.1.3 (20 june 2020) Issue #304: rewrite frontend in typescript Issue #305: don't change migration when setting changes (thanks to Lionqueen94) Issue #307: add French translations; also make translations discoverable by makemessages (thanks to Simon Maillard) 2.1.2 (20 april 2020) Issue #298: directory support for drop area Issue #300: add migration so makemigrations will not create one (thanks to Lionqueen94) 2.1.1 (7 april 2020) Issue #290: add javascript callbacks (thanks to Peter Dekkers) Issue #296: fix progress bar Issue #297: add retry delays 2.1.0 (28 march 2020) Issue #266: allow relative FILE_FORM_UPLOAD_DIR setting (thanks to Bo Peng) Issue #267: add drop area (thanks to Bo Peng) Issue #275: show size of uploaded files (thanks to Bo Peng) Issue #278: allow the addition of placeholder files (thanks to Bo Peng) Issue #280: remove option FILE_FORM_FILE_STORAGE 2.0.3 (15 february 2020) Issue #237: using with form set (thanks to Juan Carlos Carvajal) Issue #259: include uncompressed js Issue #260: correctly use formset prefix (thanks to Gzuba) Issue #261: fix default for FILE_FORM_UPLOAD_DIR (thanks to Gzuba) 2.0.2 (14 january 2020) Issue #247: support form wizard (thanks to Lionqueen94) Issue #251: delete after submit 2.0.1 (6 january 2020) Issue #240: add empty dff files div (thanks to Lionqueen94) Issue #241: Csp compliance (thanks to Lionqueen94) 2.0 (30 december 2019) Use tus instead of fine uploader 1.0 (5 december 2019) Drop support for Python 2 and Django < 2 Issue #217: update fine uploader Issue #219: use Selenium for all tests Issue #222: use pathlib2 (instead of pathlib) Issue #235: support Django 3.0 0.4.2 (3 March 2019) Issue #207: support form prefixes (thanks to Iw108) Issue #201: fix multiple file upload without ajax (thanks to Lionqueen94) 0.4.1 (5 January 2019) Issue #194: correctly call is_authenticated (thanks to Dureba) 0.4.0 (3 August 2018) Support Django 2.1 and Python 3.7 Issue #173: add i18n to upload widget (thanks to Arman Roomana) 0.3.0 (6 December 2017) Support Django 2.0","title":"Changelog"},{"location":"customization/","text":"Customization Customize upload widget The UploadWidget and UploadMultipleWidget is rendered by a template django_file_form/upload_widget.html , which contains the <input type=\"file\"> widget and a few hidden fields for additional information. You can customize the look and feel of the widget by overriding this template. Because Django by default does not use customized templates for form-rendering, you will need to Include django.form in DJANGO_APPS Add FORM_RENDERER = 'django.forms.renderers.TemplatesSetting' to settings.py Add django_file_form/upload_widget.html to your projects templates directory (or jinja2 if you use jinja2 to render the templates). The upload widget will be available as variable widget and you can use its attributes such as widget.attrs.id to customize it.","title":"Customization"},{"location":"customization/#customization","text":"","title":"Customization"},{"location":"customization/#customize-upload-widget","text":"The UploadWidget and UploadMultipleWidget is rendered by a template django_file_form/upload_widget.html , which contains the <input type=\"file\"> widget and a few hidden fields for additional information. You can customize the look and feel of the widget by overriding this template. Because Django by default does not use customized templates for form-rendering, you will need to Include django.form in DJANGO_APPS Add FORM_RENDERER = 'django.forms.renderers.TemplatesSetting' to settings.py Add django_file_form/upload_widget.html to your projects templates directory (or jinja2 if you use jinja2 to render the templates). The upload widget will be available as variable widget and you can use its attributes such as widget.attrs.id to customize it.","title":"Customize upload widget"},{"location":"details/","text":"Details Include hidden fields Make sure that hidden form fields are included: {% for hidden in form.hidden_fields %} {{ hidden }} {% endfor %} NB: it's possible that the hidden fields are already included; for example if you use form.as_p . Do not include the hidden fields twice. Also see the testproject in the repository. Temp upload dir must exist Make sure the FILE_FORM_UPLOAD_DIR directory exists. temp_upload_dir = os.path.join(settings.MEDIA_ROOT, settings.FILE_FORM_UPLOAD_DIR) if not os.path.exists(temp_upload_dir): os.mkdir(temp_upload_dir) Adding placeholder files If you have used django-file-form to upload files, potentially have saved the files elsewhere, but would like to use django-file-form to edit (remove or replace) the original uploaded files and append new files, you can add information about the original uploaded files as placeholders to the UploadedFileField . More specifically, you can initialize your field with one or more PlaceholderUploadedFile as follows: from django_file_form.models import PlaceholderUploadedFile initial['my_field'] = [ PlaceholderUploadedFile('testfile1.png') ] You can also add options size and file_id to specify file size if the file does not exist locally, and an unique ID of the file, respectively. initial['my_field'] = [ PlaceholderUploadedFile('testfile1.png', size=12394, file_id=my_file.pk) ] The placeholder file will be listed, and will either be kept intact, or be removed. When you save the form, you will have to handle the placeholders as follows: for f in self.cleaned_data['my_field']: if f.is_placeholder: # do nothing, or something with f.name or f.file_id continue # handle newly uploaded files as usual # remove existing files if the placeholders are deleted # ... Upload directly to AWS S3 django-file-form supports upload directly to AWS S3 compatible storages. The files will be uploaded by clients directly to S3 through AJAX operations and return to the backend as File objects with S3Boto3Storage . Required packages: boto3 and django_storages . To use this method, you will first need to make sure your S3 bucket is configured to allow upload to bucket directly , allow PUT method, and expose ETag header . You then need to define the following variables in settings AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_STORAGE_BUCKET_NAME AWS_S3_REGION_NAME (optional) AWS_S3_SIGNATURE_VERSION (optional) AWS_S3_ENDPOINT_URL (optional) or through environment variables with the same names as described in django-storages documentation . If you are using django-csp for setting the Content Security Policy, then the following CORS settings are also needed in settings CSP_DEFAULT_SRC = (\"'none'\",) CSP_STYLE_SRC = (\"'self'\") CSP_SCRIPT_SRC = (\"'self'\",) CSP_FONT_SRC = (\"'self'\") CSP_IMG_SRC = (\"'self'\",) CSP_CONNECT_SRC = (\"'self'\", AWS_S3_ENDPOINT_URL) where AWS_S3_ENDPOINT_URL is the AWS endpoint defined above. Finally, you will need to define s3_upload_dir = \"user_or_form_specific_id\" in the form class or passed parameter s3_upload_dir to the constructor of the form to inform the frontend to use the AJAX uploader for S3. The files will be uploaded to ${FILE_FORM_UPLOAD_DIR}/${s3_upload_dir}/ in the specified S3 bucket, where s3_upload_dir can be empty or a directory specific to user or form to avoid conflicts on the AWS side. If the object already exists in the S3 bucket, a random string will be added to filename. After form submission, the files will be returned as customized S3Boto3StorageFile objects with S3Boto3Storage as its underlying storage. The objects will have attributes is_s3direct=True , is_placeholder=False , and original_name which is the name of the file that was uploaded that can be different from the basename of the object on S3 ( f.name ). Reading from these objects will download the files from S3. Accept attribute You can add an accept attribute to the file input using the accept parameter on UploadedFileField : file = UploadedFileField(accept='image/*,.pdf') Additional file metadata If you want to add and maintain additional metadata such as short descriptions and categories of uploaded files, you can use the .metadata field of uploaded files. More specifically, the AJAX uploader has a hidden field called metadata (with form specific prefix) with its data being the JSON.dump ed meta data of all files. The data should be in the format of { 'filename1': value1, 'filename2': value2 } To add metadata to uploaded files, you will need to listen to events triggered after the additional and removal of file list (see \"Javascript events\" for details) to add your own widgets and event handlers to update the data of this hidden field. Upon form submission, django-file-form retrieves the data and assign them to returned file objects with matching filename (could be of placeholder and other types) as f.metadata . Cache Django-file-form uses the Django cache for storing data while uploading files. Only meta data of the file is stored (including the upload progress), not contents of the file. The default cache timeout is 24 hours. An upload will fail if it takes longer than that. The timeout is configurable using the FILE_FORM_CACHE_TIMEOUT setting. See the 'Python settings' section. The cache backed is configurable using FILE_FORM_CACHE . Disabled property Make the input disabled by setting the disabled attribute. class ExampleForm(FileFormMixin, Form): input_file = UploadedFileField(disabled=True) Also possibe: make the field disabled in the constructor. def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.fields[\"input_file\"].disabled = True Production Local-memory caching Don't use local-memory caching in your Django configuration if you use a multi process WSGI server. It will break file uploads, because file uploads use the Django cache and might hit different WSGI processes. The default cache option in Django is local-memory caching. Most WSGI servers are multi process. Maximum size of uploaded chunk Files are uploaded in chunks; the default size of a chunk is 2.5 MB. Your production setup must allow for uploads of this size. It's possible that you use a reverse proxy server that has a maximum file upload size. E.g. Nginx has the client_max_body_size option. Django has the DATA_UPLOAD_MAX_MEMORY_SIZE option, which also limits the upload size. You can change the maximum chunk size with the chunkSize option in Javascript. See the 'javascript options' section in this documentation.","title":"Details"},{"location":"details/#details","text":"","title":"Details"},{"location":"details/#include-hidden-fields","text":"Make sure that hidden form fields are included: {% for hidden in form.hidden_fields %} {{ hidden }} {% endfor %} NB: it's possible that the hidden fields are already included; for example if you use form.as_p . Do not include the hidden fields twice. Also see the testproject in the repository.","title":"Include hidden fields"},{"location":"details/#temp-upload-dir-must-exist","text":"Make sure the FILE_FORM_UPLOAD_DIR directory exists. temp_upload_dir = os.path.join(settings.MEDIA_ROOT, settings.FILE_FORM_UPLOAD_DIR) if not os.path.exists(temp_upload_dir): os.mkdir(temp_upload_dir)","title":"Temp upload dir must exist"},{"location":"details/#adding-placeholder-files","text":"If you have used django-file-form to upload files, potentially have saved the files elsewhere, but would like to use django-file-form to edit (remove or replace) the original uploaded files and append new files, you can add information about the original uploaded files as placeholders to the UploadedFileField . More specifically, you can initialize your field with one or more PlaceholderUploadedFile as follows: from django_file_form.models import PlaceholderUploadedFile initial['my_field'] = [ PlaceholderUploadedFile('testfile1.png') ] You can also add options size and file_id to specify file size if the file does not exist locally, and an unique ID of the file, respectively. initial['my_field'] = [ PlaceholderUploadedFile('testfile1.png', size=12394, file_id=my_file.pk) ] The placeholder file will be listed, and will either be kept intact, or be removed. When you save the form, you will have to handle the placeholders as follows: for f in self.cleaned_data['my_field']: if f.is_placeholder: # do nothing, or something with f.name or f.file_id continue # handle newly uploaded files as usual # remove existing files if the placeholders are deleted # ...","title":"Adding placeholder files"},{"location":"details/#upload-directly-to-aws-s3","text":"django-file-form supports upload directly to AWS S3 compatible storages. The files will be uploaded by clients directly to S3 through AJAX operations and return to the backend as File objects with S3Boto3Storage . Required packages: boto3 and django_storages . To use this method, you will first need to make sure your S3 bucket is configured to allow upload to bucket directly , allow PUT method, and expose ETag header . You then need to define the following variables in settings AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_STORAGE_BUCKET_NAME AWS_S3_REGION_NAME (optional) AWS_S3_SIGNATURE_VERSION (optional) AWS_S3_ENDPOINT_URL (optional) or through environment variables with the same names as described in django-storages documentation . If you are using django-csp for setting the Content Security Policy, then the following CORS settings are also needed in settings CSP_DEFAULT_SRC = (\"'none'\",) CSP_STYLE_SRC = (\"'self'\") CSP_SCRIPT_SRC = (\"'self'\",) CSP_FONT_SRC = (\"'self'\") CSP_IMG_SRC = (\"'self'\",) CSP_CONNECT_SRC = (\"'self'\", AWS_S3_ENDPOINT_URL) where AWS_S3_ENDPOINT_URL is the AWS endpoint defined above. Finally, you will need to define s3_upload_dir = \"user_or_form_specific_id\" in the form class or passed parameter s3_upload_dir to the constructor of the form to inform the frontend to use the AJAX uploader for S3. The files will be uploaded to ${FILE_FORM_UPLOAD_DIR}/${s3_upload_dir}/ in the specified S3 bucket, where s3_upload_dir can be empty or a directory specific to user or form to avoid conflicts on the AWS side. If the object already exists in the S3 bucket, a random string will be added to filename. After form submission, the files will be returned as customized S3Boto3StorageFile objects with S3Boto3Storage as its underlying storage. The objects will have attributes is_s3direct=True , is_placeholder=False , and original_name which is the name of the file that was uploaded that can be different from the basename of the object on S3 ( f.name ). Reading from these objects will download the files from S3.","title":"Upload directly to AWS S3"},{"location":"details/#accept-attribute","text":"You can add an accept attribute to the file input using the accept parameter on UploadedFileField : file = UploadedFileField(accept='image/*,.pdf')","title":"Accept attribute"},{"location":"details/#additional-file-metadata","text":"If you want to add and maintain additional metadata such as short descriptions and categories of uploaded files, you can use the .metadata field of uploaded files. More specifically, the AJAX uploader has a hidden field called metadata (with form specific prefix) with its data being the JSON.dump ed meta data of all files. The data should be in the format of { 'filename1': value1, 'filename2': value2 } To add metadata to uploaded files, you will need to listen to events triggered after the additional and removal of file list (see \"Javascript events\" for details) to add your own widgets and event handlers to update the data of this hidden field. Upon form submission, django-file-form retrieves the data and assign them to returned file objects with matching filename (could be of placeholder and other types) as f.metadata .","title":"Additional file metadata"},{"location":"details/#cache","text":"Django-file-form uses the Django cache for storing data while uploading files. Only meta data of the file is stored (including the upload progress), not contents of the file. The default cache timeout is 24 hours. An upload will fail if it takes longer than that. The timeout is configurable using the FILE_FORM_CACHE_TIMEOUT setting. See the 'Python settings' section. The cache backed is configurable using FILE_FORM_CACHE .","title":"Cache"},{"location":"details/#disabled-property","text":"Make the input disabled by setting the disabled attribute. class ExampleForm(FileFormMixin, Form): input_file = UploadedFileField(disabled=True) Also possibe: make the field disabled in the constructor. def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.fields[\"input_file\"].disabled = True","title":"Disabled property"},{"location":"details/#production","text":"","title":"Production"},{"location":"details/#local-memory-caching","text":"Don't use local-memory caching in your Django configuration if you use a multi process WSGI server. It will break file uploads, because file uploads use the Django cache and might hit different WSGI processes. The default cache option in Django is local-memory caching. Most WSGI servers are multi process.","title":"Local-memory caching"},{"location":"details/#maximum-size-of-uploaded-chunk","text":"Files are uploaded in chunks; the default size of a chunk is 2.5 MB. Your production setup must allow for uploads of this size. It's possible that you use a reverse proxy server that has a maximum file upload size. E.g. Nginx has the client_max_body_size option. Django has the DATA_UPLOAD_MAX_MEMORY_SIZE option, which also limits the upload size. You can change the maximum chunk size with the chunkSize option in Javascript. See the 'javascript options' section in this documentation.","title":"Maximum size of uploaded chunk"},{"location":"form_sets/","text":"Form sets You can also use a form set instead of a form. In that case initFormSet (instead of initUploadFields ) in your javascript code. initFormSet(form_element, options) initFormSet( document.getElementById(\"example-form\"), { prefix: \"form\" } ); Note that the default form set prefix is form . Also see the testproject directory in the repository for an example.","title":"Form sets"},{"location":"form_sets/#form-sets","text":"You can also use a form set instead of a form. In that case initFormSet (instead of initUploadFields ) in your javascript code. initFormSet(form_element, options) initFormSet( document.getElementById(\"example-form\"), { prefix: \"form\" } ); Note that the default form set prefix is form . Also see the testproject directory in the repository for an example.","title":"Form sets"},{"location":"internals/","text":"Internals The TemporaryUploadedFile model The django-file-form app uses the TemporaryUploadedFile model internally for temporary storage. If you want to store files in the database, you should use your own model for that. Also see the Example model in the django_file_form_example app.","title":"Internals"},{"location":"internals/#internals","text":"","title":"Internals"},{"location":"internals/#the-temporaryuploadedfile-model","text":"The django-file-form app uses the TemporaryUploadedFile model internally for temporary storage. If you want to store files in the database, you should use your own model for that. Also see the Example model in the django_file_form_example app.","title":"The TemporaryUploadedFile model"},{"location":"javascript_events/","text":"Javascript events There are javascript events for adding and removing an upload. The events are addUpload , removeUpload , and uploadComplete . import EventEmitter from 'eventemitter3'; const eventEmitter = new EventEmitter(); eventEmitter.on('addUpload', ({ element, fieldName, fileName, metaDataField, upload }) => { // }); eventEmitter.on('removeUpload', ({ element, fieldName, fileName, metaDataField, upload }) => { // }); eventEmitter.on('uploadComplete', ({ element, fieldName, fileName, metaDataField, upload }) => { // }); initUploadFields( document.getElementById(\"example-form\"), { eventEmitter, } ); You need the eventemitter3 package to use this. The metaDataField is the metadata input. See 'Additional file metadata' in this document. This api is experimental.","title":"Javascript events"},{"location":"javascript_events/#javascript-events","text":"There are javascript events for adding and removing an upload. The events are addUpload , removeUpload , and uploadComplete . import EventEmitter from 'eventemitter3'; const eventEmitter = new EventEmitter(); eventEmitter.on('addUpload', ({ element, fieldName, fileName, metaDataField, upload }) => { // }); eventEmitter.on('removeUpload', ({ element, fieldName, fileName, metaDataField, upload }) => { // }); eventEmitter.on('uploadComplete', ({ element, fieldName, fileName, metaDataField, upload }) => { // }); initUploadFields( document.getElementById(\"example-form\"), { eventEmitter, } ); You need the eventemitter3 package to use this. The metaDataField is the metadata input. See 'Additional file metadata' in this document. This api is experimental.","title":"Javascript events"},{"location":"javascript_options/","text":"Javascript options Signature of initUploadFields is: initUploadFields(formDomElement, options); formDomElement (required); e.g. document.getElementById(\"example-form\") options (optional) callbacks : callbacks for things like upload progress and errors. chunkSize : the maximum size of an upload. Default is 2.5 MB. Note that Django limits the size of a request. See https://docs.djangoproject.com/en/4.1/ref/settings/#data-upload-max-memory-size. eventEmitter : experimental api for events. See 'Javascript events' section below prefix : set this if the Django form has a prefix; default is empty retryDelays : set retry delays Also see https://github.com/tus/tus-js-client#tusdefaultoptions Default is [0, 1000, 3000, 5000] skipRequired : don't set the required field of the file input; default is false supportDropArea : add a drop area; default is true The callbacks are: onClick Called when the filename of an uploaded file is clicked Signature of callback is function({ fileName, fieldName, type }) fileName: the file name fieldName: the name of the form field id: the id of the temporary uploaded file type: tus or uploadedTus : uploaded file placeholder : placeholder existing : existing file The filename is rendered with the dff-filename class. You can use this class to change the styling. onDelete Called when file is deleted Signature of callback is function(upload) onError : Called when an upload error occurs Signature of callback is function(error, upload) error : javascript Error onProgress : Called each time when progress information is available. Signature of callback is function(bytesUploaded, bytesTotal, upload) onSuccess : Called when file upload is done. Signature of callback is function(upload) The callbacks receive an upload parameter which is this class . Examples: initUploadFields(document.getElementById(\"example-form\")); initUploadFields(document.getElementById(\"example-form\"), { prefix: \"example\", skipRequired: true, supportDropArea: true, });","title":"Javascript options"},{"location":"javascript_options/#javascript-options","text":"Signature of initUploadFields is: initUploadFields(formDomElement, options); formDomElement (required); e.g. document.getElementById(\"example-form\") options (optional) callbacks : callbacks for things like upload progress and errors. chunkSize : the maximum size of an upload. Default is 2.5 MB. Note that Django limits the size of a request. See https://docs.djangoproject.com/en/4.1/ref/settings/#data-upload-max-memory-size. eventEmitter : experimental api for events. See 'Javascript events' section below prefix : set this if the Django form has a prefix; default is empty retryDelays : set retry delays Also see https://github.com/tus/tus-js-client#tusdefaultoptions Default is [0, 1000, 3000, 5000] skipRequired : don't set the required field of the file input; default is false supportDropArea : add a drop area; default is true The callbacks are: onClick Called when the filename of an uploaded file is clicked Signature of callback is function({ fileName, fieldName, type }) fileName: the file name fieldName: the name of the form field id: the id of the temporary uploaded file type: tus or uploadedTus : uploaded file placeholder : placeholder existing : existing file The filename is rendered with the dff-filename class. You can use this class to change the styling. onDelete Called when file is deleted Signature of callback is function(upload) onError : Called when an upload error occurs Signature of callback is function(error, upload) error : javascript Error onProgress : Called each time when progress information is available. Signature of callback is function(bytesUploaded, bytesTotal, upload) onSuccess : Called when file upload is done. Signature of callback is function(upload) The callbacks receive an upload parameter which is this class . Examples: initUploadFields(document.getElementById(\"example-form\")); initUploadFields(document.getElementById(\"example-form\"), { prefix: \"example\", skipRequired: true, supportDropArea: true, });","title":"Javascript options"},{"location":"model_forms/","text":"Model forms You can add a file upload to a ModelForm by setting the field_classes attribute: class ExampleModelForm(FileFormMixin, ModelForm): class Meta: model = Example fields = (\"title\", \"input_file\") field_classes = dict( input_file=UploadedFileField, ) Also see ExampleModelForm and ExampleMultipleModelForm in the test project.","title":"Model forms"},{"location":"model_forms/#model-forms","text":"You can add a file upload to a ModelForm by setting the field_classes attribute: class ExampleModelForm(FileFormMixin, ModelForm): class Meta: model = Example fields = (\"title\", \"input_file\") field_classes = dict( input_file=UploadedFileField, ) Also see ExampleModelForm and ExampleMultipleModelForm in the test project.","title":"Model forms"},{"location":"python_settings/","text":"Python settings Settings in settings.py : FILE_FORM_CACHE_TIMEOUT (int) Cache timeout in seconds The Default is 24 hours FILE_FORM_MUST_LOGIN (True / False): Must the user be logged in to upload a file. The default is False . FILE_FORM_UPLOAD_DIR (string): The directory for the temporary uploads. The setting is relative to MEDIA_ROOT . The default is temp_uploads . FILE_FORM_TEMP_STORAGE (string): Dotted path to the class that is used to store temporary uploads. The default is django.core.files.storage.FileSystemStorage . Note that files will be uploaded to the local file system first regardless. This storage backend will be used only for fully uploaded files that are then passed back to the form when it's submitted. FILE_FORM_CACHE (string): Name of a cache backend defined in settings.CACHES . The default is Django's default cache. The cache is used to store data about files while they are being uploaded. If the default might be cleared while a file upload is in progress then using a different backend like django's database cache might be more appropriate. Note that cache.clear() will clear the whole cache at a specified LOCATION regardless what the KEY_PREFIX is. FILE_UPLOAD_PERMISSIONS (octal) [django-setting]: This is a setting from the DJANGO core. Sets the the permissions for the uploaded files, for example: 0o644. See more details","title":"Python settings"},{"location":"python_settings/#python-settings","text":"Settings in settings.py : FILE_FORM_CACHE_TIMEOUT (int) Cache timeout in seconds The Default is 24 hours FILE_FORM_MUST_LOGIN (True / False): Must the user be logged in to upload a file. The default is False . FILE_FORM_UPLOAD_DIR (string): The directory for the temporary uploads. The setting is relative to MEDIA_ROOT . The default is temp_uploads . FILE_FORM_TEMP_STORAGE (string): Dotted path to the class that is used to store temporary uploads. The default is django.core.files.storage.FileSystemStorage . Note that files will be uploaded to the local file system first regardless. This storage backend will be used only for fully uploaded files that are then passed back to the form when it's submitted. FILE_FORM_CACHE (string): Name of a cache backend defined in settings.CACHES . The default is Django's default cache. The cache is used to store data about files while they are being uploaded. If the default might be cleared while a file upload is in progress then using a different backend like django's database cache might be more appropriate. Note that cache.clear() will clear the whole cache at a specified LOCATION regardless what the KEY_PREFIX is. FILE_UPLOAD_PERMISSIONS (octal) [django-setting]: This is a setting from the DJANGO core. Sets the the permissions for the uploaded files, for example: 0o644. See more details","title":"Python settings"},{"location":"translations/","text":"Translations To update a translation or add new language Fork this repo as usual # enter in project folder cd django-file-form # create virtualenv (example using pipenv) pipenv install --python=3 -r testproject/requirements.txt # enter in venv shell pipenv shell # update po file for your language django-admin makemessages -l fr You can now edit generated po file and commit your changes as usual","title":"Translations"},{"location":"translations/#translations","text":"To update a translation or add new language Fork this repo as usual # enter in project folder cd django-file-form # create virtualenv (example using pipenv) pipenv install --python=3 -r testproject/requirements.txt # enter in venv shell pipenv shell # update po file for your language django-admin makemessages -l fr You can now edit generated po file and commit your changes as usual","title":"Translations"},{"location":"upgrade/","text":"Upgrade from version 1.0 (to 2.0) Add reference to file_form/file_form.css: <link rel=\"stylesheet\" href=\"{% static \"file_form/file_form.css\" %}\"> Remove django_file_form.ajaxuploader from INSTALLED_APPS in your settings Remove reference to ajaxuploader/js/fileuploader.js in your template Remove reference to ajaxuploader/css/fileuploader.css in your template You don't have to include jquery; the fileuploader doesn't use it The setting FILE_FORM_UPLOAD_BACKEND is removed If you use custom css, you might have to change it. The html uses the prefix dff now.","title":"Upgrade"},{"location":"upgrade/#upgrade-from-version-10-to-20","text":"Add reference to file_form/file_form.css: <link rel=\"stylesheet\" href=\"{% static \"file_form/file_form.css\" %}\"> Remove django_file_form.ajaxuploader from INSTALLED_APPS in your settings Remove reference to ajaxuploader/js/fileuploader.js in your template Remove reference to ajaxuploader/css/fileuploader.css in your template You don't have to include jquery; the fileuploader doesn't use it The setting FILE_FORM_UPLOAD_BACKEND is removed If you use custom css, you might have to change it. The html uses the prefix dff now.","title":"Upgrade from version 1.0 (to 2.0)"},{"location":"usage/","text":"Usage 1 Install django-file-form pip install django-file-form 2 Add the apps to your INSTALLED_APPS You must include 'django_file_form' INSTALLED_APPS = [ 'django_file_form', ] 3 Add the app to your urls In this example we use the url upload/ . You can use a different url if you like. urlpatterns = patterns( '', url(r'^upload/', include('django_file_form.urls')), ) 4 Add FileFormMixin to your form from django_file_form.forms import FileFormMixin class ExampleForm(FileFormMixin, forms.Form): pass 5 Add a UploadedFileField from django_file_form.forms import FileFormMixin, UploadedFileField class ExampleForm(FileFormMixin, forms.Form): input_file = UploadedFileField() Import and use MultipleUploadedFileField if you intent to add multiple files. 6 Include javascript and css in your template <script src=\"{% static \"file_form/file_form.min.js\" %}\"></script> <link rel=\"stylesheet\" href=\"{% static \"file_form/file_form.css\" %}\"> There is also an uncompressed javascript version: file_form/file_form.js . 7 Call the initUploadFields javascript function <form id=\"example-form\" method=\"POST\" enctype=\"multipart/form-data\"> {% csrf_token %} {{ form }} </form> <script> initUploadFields(document.getElementById(\"example-form\")); </script> If your form has a prefix, then call initUploadFields as follows: // for example, with prefix 'abc' initUploadFields(document.getElementById(\"example-form\"), { prefix: \"abc\" }); See the Django documentation for more information about form prefixes. 8 Handle uploaded files class ExampleFormView(generic.FormView): template_name = 'example_form.html' form_class = forms.ExampleForm def form_valid(self, form): input_file = form.cleaned_data['input_file'] return super(ExampleFormView, self).form_valid(form) 9 Delete temporary files class ExampleFormView(generic.FormView): template_name = 'example_form.html' form_class = forms.ExampleForm def form_valid(self, form): input_file = form.cleaned_data['input_file'] form.delete_temporary_files() return super(ExampleFormView, self).form_valid(form) It's also possible to delete unused temporary file using a management command: python manage.py delete_unused_files The command deletes temporary files and records that are created at least one day ago.","title":"Usage"},{"location":"usage/#usage","text":"1 Install django-file-form pip install django-file-form 2 Add the apps to your INSTALLED_APPS You must include 'django_file_form' INSTALLED_APPS = [ 'django_file_form', ] 3 Add the app to your urls In this example we use the url upload/ . You can use a different url if you like. urlpatterns = patterns( '', url(r'^upload/', include('django_file_form.urls')), ) 4 Add FileFormMixin to your form from django_file_form.forms import FileFormMixin class ExampleForm(FileFormMixin, forms.Form): pass 5 Add a UploadedFileField from django_file_form.forms import FileFormMixin, UploadedFileField class ExampleForm(FileFormMixin, forms.Form): input_file = UploadedFileField() Import and use MultipleUploadedFileField if you intent to add multiple files. 6 Include javascript and css in your template <script src=\"{% static \"file_form/file_form.min.js\" %}\"></script> <link rel=\"stylesheet\" href=\"{% static \"file_form/file_form.css\" %}\"> There is also an uncompressed javascript version: file_form/file_form.js . 7 Call the initUploadFields javascript function <form id=\"example-form\" method=\"POST\" enctype=\"multipart/form-data\"> {% csrf_token %} {{ form }} </form> <script> initUploadFields(document.getElementById(\"example-form\")); </script> If your form has a prefix, then call initUploadFields as follows: // for example, with prefix 'abc' initUploadFields(document.getElementById(\"example-form\"), { prefix: \"abc\" }); See the Django documentation for more information about form prefixes. 8 Handle uploaded files class ExampleFormView(generic.FormView): template_name = 'example_form.html' form_class = forms.ExampleForm def form_valid(self, form): input_file = form.cleaned_data['input_file'] return super(ExampleFormView, self).form_valid(form) 9 Delete temporary files class ExampleFormView(generic.FormView): template_name = 'example_form.html' form_class = forms.ExampleForm def form_valid(self, form): input_file = form.cleaned_data['input_file'] form.delete_temporary_files() return super(ExampleFormView, self).form_valid(form) It's also possible to delete unused temporary file using a management command: python manage.py delete_unused_files The command deletes temporary files and records that are created at least one day ago.","title":"Usage"}]}